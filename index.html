<!DOCTYPE html>
<html lang="en-US">
<head>
    <!-- SEO & Metadata -->
    <meta charset="UTF-8">
    <title>Sprite Sidescroller, an 8-bit Game Generator / Level Editor</title>
    <meta name="description" content="Create, play, and share your own 8-bit side-scrolling platformer levels with this in-browser game generator and level editor. Build worlds with custom sprites and challenge your friends!">
    <meta name="keywords" content="sprite sidescroller, 8-bit game, game generator, level editor, platformer, retro game, pixel art, javascript game, html5 game, create a game">
    <meta name="author" content="Chris Pirillo">
    <link rel="canonical" href="https://pirillo.com/arcade/sprite-sidescroller.html">

    <!-- Core Web Vitals & Performance: Viewport and Resource Hints -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="preload" href="https://pirillo.com/arcade/images/sprite-sidescroller.png" as="image">

    <!-- Open Graph (for social sharing) -->
    <meta property="og:title" content="Sprite Sidescroller, an 8-bit Game Generator / Level Editor">
    <meta property="og:description" content="Create, play, and share your own 8-bit side-scrolling platformer levels with this in-browser game generator and level editor.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/sprite-sidescroller.html">
    <meta property="og:image" content="https://pirillo.com/arcade/images/sprite-sidescroller.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Pirillo.com Arcade">

    <!-- Twitter Card (for Twitter sharing) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Sprite Sidescroller, an 8-bit Game Generator / Level Editor">
    <meta name="twitter:description" content="Create, play, and share your own 8-bit side-scrolling platformer levels with this in-browser game generator and level editor.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/sprite-sidescroller.png">

    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"></noscript>

    <style>
        html, body {
            overflow: hidden; /* Prevent page scrolling on all devices */
        }
        :root {
            --font-retro: 'Press Start 2P', cursive;
            --color-dark: #1a1a1a;
            --color-light: #f0f0f0;
            --color-primary: #FFD700;
            --color-secondary: #F44336;
            --color-accent: #4CAF50;
            --color-sky: #3B82F6;
            --color-panel: #2a2a2a;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 20px 10px;
            background-color: var(--color-dark);
            color: var(--color-light);
            font-family: var(--font-retro);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            /* overflow-x: hidden; /* Prevent horizontal scrolling - now handled by html, body overflow hidden */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE 10+ */
        }
        .header-container { display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        h1 { color: var(--color-primary); text-shadow: 3px 3px var(--color-secondary); margin: 0; font-size: clamp(1.2em, 5vw, 2em); text-align: center; white-space: nowrap; }
        #modeToggle { background: none; border: 1px solid var(--color-light); border-radius: 4px; color: var(--color-light); font-family: var(--font-retro); cursor: pointer; font-size: 0.8em; padding: 5px 10px; white-space: nowrap; }
        #modeToggle:hover { color: var(--color-primary); }
        
        /* Hide edit button on small screens (smartphones) */
        @media (max-width: 767px) {
            #modeToggle {
                display: none;
            }
        }

        .main-container { display: flex; width: 100%; justify-content: center; position: relative; flex-direction: column; align-items: center; } /* Changed to column for mobile */
        .game-wrapper { display: flex; flex-direction: column; align-items: center; max-width: 100%; width: 800px; position: relative; }
        .game-container { display: flex; border: 4px solid var(--color-light); box-shadow: 0 0 20px var(--color-primary); width: 100%; position: relative; }
        canvas#gameCanvas { 
            background-color: var(--color-sky); 
            display: block; 
            image-rendering: pixelated; 
            cursor: crosshair; 
            width: 100%; 
            height: auto; 
            aspect-ratio: 800 / 640;
            touch-action: manipulation; /* Prevent pinch-to-zoom and default touch actions */
        }
        
        /* Mobile layout: editor column below game canvas */
        .editor-column { 
            display: none; /* Hidden by default */
            flex-direction: column; 
            gap: 20px; 
            width: 100%; 
            max-width: 800px; 
            position: static; 
            margin-top: 20px; 
        }
        .editor-column.is-editing { 
            display: flex; /* Show when in editing mode */
        }
        
        .map-palette-panel, .controls-panel { background-color: rgba(42, 42, 42, 0.9); padding: 15px; border: 4px solid var(--color-light); display: flex; flex-direction: column; align-items: center; width: 100%; }
        .controls-panel { gap: 10px; }
        .button { background-color: var(--color-accent); color: var(--color-light); border: 2px solid var(--color-light); padding: 10px 15px; font-family: var(--font-retro); cursor: pointer; text-transform: uppercase; font-size: 10px; width: 100%; text-align: center; transition: background-color 0.2s, transform 0.1s; white-space: nowrap; }
        .button:hover { background-color: #3e8e41; transform: translateY(-2px); }
        .button:active { transform: translateY(0); }
        .button--secondary { background-color: var(--color-secondary); }
        .button--secondary:hover { background-color: #c62828; }

        #minimapCanvas { background-color: #000; border: 2px solid #fff; cursor: pointer; width: 100%; margin-bottom: 15px; }
        .tile-palette-list { list-style: none; padding: 0; width: 100%; display: grid; grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); gap: 10px; }
        .tile-palette-item { display: flex; align-items: center; justify-content: center; cursor: pointer; padding: 5px; border: 2px solid transparent; height: 50px; }
        .tile-palette-item.selected { border-color: var(--color-primary); }
        .tile-palette-icon { 
            width: 32px; 
            height: 32px; 
            border: 1px solid #fff; 
            image-rendering: pixelated; 
            background-size:cover; 
            flex-shrink: 0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            color: transparent; /* Hide the '?' and '*' text */
        }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 1002; padding: 10px; }
        .modal-content { background-color: var(--color-panel); padding: 20px; border: 4px solid var(--color-light); position: relative; width: 100%; max-width: 600px; font-family: var(--font-retro); }
        .modal-content h2 { font-size: 1.2em; margin-top: 0; }
        .modal-content p { font-size: 12px; line-height: 1.5; margin-bottom: 20px; }
        .modal-content input[type="text"] { width: 100%; padding: 10px; font-family: var(--font-retro); background-color: #111; border: 2px solid var(--color-light); color: var(--color-light); margin-bottom: 15px; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; }
        .modal-close-button { position: absolute; top: 5px; right: 10px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; font-family: sans-serif; }
        
        /* Sprite Editor Layout Adjustments */
        .sprite-editor-layout {
            display: flex;
            flex-direction: column; /* Default to column for mobile */
            gap: 20px;
            margin-top: 20px;
        }
        .modal-content #sprite-editor-list { /* Specificity for modal's sprite list */
            display: grid; /* Use grid for better layout control */
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* More flexible grid for small screens */
            gap: 10px;
            flex-shrink: 0;
            max-width: 100%; /* Allow it to take full width */
            overflow-y: auto; /* Enable scrolling if content overflows */
            max-height: 200px; /* Limit height on small screens */
            padding-right: 10px; /* Add some padding for scrollbar */
        }
        .sprite-edit-button {
            width: 80px; /* Fixed width for uniformity */
            height: 80px; /* Fixed height for uniformity */
            padding: 0; /* Remove padding to let content fill */
            border: 1px solid var(--color-light); /* Thinner border */
            border-radius: 4px; /* Slightly rounded corners */
            cursor: pointer;
            font-family: var(--font-retro);
            font-size: 0; /* Hide text, replaced by icon */
            text-align: center;
            background-color: var(--color-panel); /* Consistent background */
            color: var(--color-light);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: flex; /* Use flex to center icon */
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.5); /* Subtle shadow */
            overflow: hidden; /* Ensure icon doesn't overflow */
        }
        .sprite-edit-button .sprite-icon-preview {
            width: 100%; /* Make icon fill button */
            height: 100%;
            image-rendering: pixelated;
            background-size: contain; /* Contain the sprite within the button */
            background-position: center;
            background-repeat: no-repeat;
        }
        .sprite-edit-button:hover {
            background-color: #3a3a3a; /* Darker on hover */
            color: var(--color-primary);
            border-color: var(--color-primary);
        }
        .sprite-edit-button.active {
            background-color: var(--color-panel); /* Keep background same as inactive */
            color: var(--color-light); /* Keep text color same */
            border-color: magenta; /* Active border color */
            box-shadow: 0 0 8px magenta; /* Add a glow effect */
        }

        #pixel-editor-container { flex-grow: 1; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #pixel-grid { display: grid; border: 2px solid var(--color-light); width: 100%; max-width: 320px; aspect-ratio: 1/1; }
        .pixel { background-color: #fff; cursor: crosshair; }
        #color-palette { display: grid; grid-template-columns: repeat(auto-fit, minmax(24px, 1fr)); /* Responsive columns for color palette */ gap: 5px; position: relative; width: 100%; max-width: 320px; }
        .color-swatch { width: 24px; height: 24px; border: 2px solid var(--color-light); cursor: pointer; }
        .color-swatch.selected { outline: 2px solid var(--color-primary); transform: scale(1.1); }
        #loadSessionModal .session-list, #levelManagerModal .level-manager-list { list-style: none; padding: 0; margin-top: 15px; max-height: 300px; overflow-y: auto; }
        #loadSessionModal .session-item, #levelManagerModal .level-manager-item { padding: 10px; border: 2px solid var(--color-light); margin-bottom: 10px; display: flex; flex-direction: column; align-items: flex-start; gap: 10px; }
        #loadSessionModal .session-item:hover { background-color: #444; }
        .level-manager-item .level-name { flex-grow: 1; font-size: 12px; word-break: break-all; }
        .level-manager-item .level-controls { display: flex; gap: 8px; flex-wrap: wrap; }
        .level-manager-item .level-controls button { font-size: 8px; padding: 5px; width: auto; min-width: 40px; }
        #custom-color-picker { display: none; position: absolute; background: var(--color-panel); border: 2px solid var(--color-light); padding: 10px; z-index: 1003; width: 220px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #color-box { width: 100%; height: 150px; cursor: crosshair; position: relative; }
        #color-slider { width: 100%; height: 20px; cursor: pointer; }
        #color-box-indicator { position: absolute; width: 10px; height: 10px; border: 2px solid white; border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%); }
        .picker-buttons { display: flex; justify-content: space-between; margin-top: 10px; }
        .picker-buttons button { font-size: 10px; padding: 5px 10px; width: 48%; }
        .visually-hidden { position:absolute; width:1px; height:1px; margin:-1px; padding:0; overflow:hidden; clip:rect(0,0,0,0); border:0; }
        
        /* Tablet/Desktop layout: editor column positioned absolutely next to game canvas */
        @media (min-width: 768px) {
            .main-container { flex-direction: row; align-items: flex-start; } /* Back to row for desktop */
            .game-wrapper { position: relative; } /* Needed for absolute positioning of editor */
            .editor-column {
                position: absolute;
                top: 20px; /* Adjust as needed */
                right: 20px; /* Default to right side */
                width: 220px; /* Fixed width for editor */
                z-index: 10;
                margin-top: 0; /* Override mobile margin */
                /* display: flex; This is now controlled by .is-editing class only */
            }
            /* Class to shift editor to left side */
            .editor-column.editor-column--left {
                left: 20px;
                right: auto; /* Remove right positioning */
            }
            .sprite-editor-layout { flex-direction: row; } /* For sprite editor modal */
            .modal-content #sprite-editor-list {
                grid-template-columns: repeat(2, 1fr); /* Two columns for desktop sprite list */
                max-width: 200px; /* Constrain width on desktop */
                max-height: none; /* Remove height limit on desktop */
            }
        }

        /* Larger desktop screens: position editor further out */
        @media (min-width: 1241px) {
            .editor-column {
                top: 0; /* Align with top of game canvas */
                right: calc((100vw - 800px) / 2 - 220px - 20px); /* Position outside game wrapper */
            }
            .editor-column.editor-column--left {
                left: calc((100vw - 800px) / 2 - 220px - 20px);
                right: auto;
            }
        }
    </style>

    <script type="application/ld+json">
    {
      "@context": "https://schema.org", "@type": "VideoGame", "name": "Sprite Sidescroller, an 8-bit Game Generator / Level Editor", "url": "https://pirillo.com/arcade/sprite-sidescroller.html",
      "author": { "@type": "Person", "name": "Chris Pirillo" }, "image": "https://pirillo.com/arcade/images/sprite-sidescroller.png",
      "description": "Create, play, and share your own 8-bit side-scrolling platformer levels with this in-browser game generator and level editor. Build worlds with custom sprites and challenge your friends!",
      "applicationCategory": "Game", "gamePlatform": ["PC", "WebBrowser"], "operatingSystem": "All", "keywords": "sprite sidescroller, 8-bit game, game generator, level editor, platformer, retro game, pixel art"
    }
    </script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>
</head>
<body>
    <header class="header-container">
        <h1>Sprite Sidescroller</h1>
        <button id="modeToggle" type="button">Edit</button>
    </header>

    <main class="main-container" id="mainContainer">
        <div class="game-wrapper">
            <div class="game-container">
                <canvas id="gameCanvas" width="800" height="640"></canvas>
            </div>
        </div>
        <aside class="editor-column">
            <section class="map-palette-panel" id="mapPaletteContainer" aria-labelledby="map-palette-heading">
                <h2 id="map-palette-heading" class="visually-hidden">Map and Tile Palette</h2>
                <canvas id="minimapCanvas" width="190" height="19"></canvas>
                <ul class="tile-palette-list" role="toolbar" aria-label="Tile Palette">
                    <li class="tile-palette-item selected" data-tile-type="1" title="Ground"><div class="tile-palette-icon" id="key-ground" role="button" aria-pressed="true" aria-label="Select Ground Tile"></div></li>
                    <li class="tile-palette-item" data-tile-type="2" title="Brick"><div class="tile-palette-icon" id="key-brick" role="button" aria-pressed="false" aria-label="Select Brick Tile"></div></li>
                    <li class="tile-palette-item" data-tile-type="3" title="Question"><div class="tile-palette-icon" id="key-question" role="button" aria-pressed="false" aria-label="Select Question Block Tile"></div></li>
                    <li class="tile-palette-item" data-tile-type="4" title="Bumper"><div class="tile-palette-icon" id="key-bumper" role="button" aria-pressed="false" aria-label="Select Bumper Tile"></div></li>
                    <li class="tile-palette-item" data-tile-type="5" title="Coin"><div class="tile-palette-icon" id="key-coin" role="button" aria-pressed="false" aria-label="Select Coin Tile"></div></li>
                    <li class="tile-palette-item" data-tile-type="6" title="Goal"><div class="tile-palette-icon" id="key-goal" role="button" aria-pressed="false" aria-label="Select Goal Tile"></div></li>
                </ul>
            </section>
            <section class="controls-panel" id="controlsContainer" aria-labelledby="controls-heading">
                <h2 id="controls-heading" class="visually-hidden">Level Controls</h2>
                <button class="button" id="saveJson" type="button">Export Project</button>
                <button class="button" id="loadJson" type="button">Import Project</button>
                <button class="button" id="saveLocal" type="button">Save Project</button>
                <button class="button" id="loadLocal" type="button">Load Project</button>
                <button class="button" id="openSpriteEditor" type="button">Edit Sprites</button>
                <button class="button" id="manageLevels" type="button">Manage Levels</button>
                <button class="button" id="generateLevel" type="button">Add New Level</button>
            </section>
        </aside>
    </main>
    
    <div id="spriteEditorModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="sprite-editor-heading">
        <div class="modal-content">
            <button id="closeSpriteEditorModal" class="modal-close-button" type="button" aria-label="Close Sprite Editor">&times;</button>
            <h2 id="sprite-editor-heading">Sprite Editor</h2>
            <div class="sprite-editor-layout">
                <div id="sprite-editor-list" role="tablist" aria-orientation="vertical"></div>
                <div id="pixel-editor-container">
                    <div id="pixel-grid" role="grid" aria-label="Pixel Editor"></div>
                    <div id="color-palette" role="radiogroup" aria-label="Color Palette"></div>
                </div>
            </div>
            <p style="font-size:10px; text-align:center; margin-top:15px;">Changes are saved automatically.<br>Double-click a color to change it.</p>
        </div>
    </div>
    
    <div id="custom-color-picker" role="dialog" aria-modal="true" aria-label="Custom Color Picker">
        <canvas id="color-box" width="200" height="150"></canvas>
        <div id="color-box-indicator"></div>
        <canvas id="color-slider" width="200" height="20"></canvas>
        <div class="picker-buttons">
            <button id="picker-ok" class="button" type="button">OK</button>
            <button id="picker-cancel" class="button" type="button">Cancel</button>
        </div>
    </div>

    <div id="loadSessionModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="load-session-heading">
        <div class="modal-content">
            <button id="closeLoadModal" class="modal-close-button" type="button" aria-label="Close Load Project Dialog">&times;</button>
            <h2 id="load-session-heading">Load Project</h2>
            <ul class="session-list" id="sessionList"></ul>
        </div>
    </div>

    <div id="saveSessionModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="save-session-heading">
        <div class="modal-content">
            <button id="closeSaveModal" class="modal-close-button" type="button" aria-label="Close Save Project Dialog">&times;</button>
            <h2 id="save-session-heading">Save Project</h2>
            <label for="sessionNameInput" class="visually-hidden">Project Name</label>
            <input type="text" id="sessionNameInput" placeholder="Enter project name...">
            <div class="modal-buttons">
                <button class="button" id="confirmSaveButton" type="button">Save</button>
            </div>
        </div>
    </div>
    
    <div id="levelManagerModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="level-manager-heading">
        <div class="modal-content">
            <button id="closeLevelManagerModal" class="modal-close-button" type="button" aria-label="Close Level Manager">&times;</button>
            <h2 id="level-manager-heading">Level Manager</h2>
            <ul class="level-manager-list" id="levelManagerList"></ul>
        </div>
    </div>

    <div id="confirmModal" class="modal-overlay" role="alertdialog" aria-modal="true" aria-labelledby="confirm-heading">
        <div class="modal-content">
            <h2 id="confirm-heading">Confirm</h2>
            <p id="confirmMessage"></p>
            <div class="modal-buttons">
                <button id="confirmCancel" class="button">Cancel</button>
                <button id="confirmOk" class="button button--secondary">OK</button>
            </div>
        </div>
    </div>

    <div id="promptModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="prompt-heading">
        <div class="modal-content">
            <h2 id="prompt-heading">Rename Level</h2>
            <p id="promptMessage"></p>
            <input type="text" id="promptInput">
            <div class="modal-buttons">
                <button id="promptCancel" class="button">Cancel</button>
                <button id="promptOk" class="button">OK</button>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas and DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const modeToggleButton = document.getElementById('modeToggle');
        const editorColumn = document.querySelector('.editor-column');
        ctx.imageSmoothingEnabled = false;
        minimapCtx.imageSmoothingEnabled = false;

        // --- Game Configuration ---
        const TILE_SIZE = 32;
        const LEVEL_WIDTH_TILES = 200;
        const LEVEL_HEIGHT_TILES = 20;
        const VISIBLE_WIDTH_TILES = 25;
        canvas.width = VISIBLE_WIDTH_TILES * TILE_SIZE;
        canvas.height = LEVEL_HEIGHT_TILES * TILE_SIZE;

        // --- Player Properties ---
        const player = { 
            x: TILE_SIZE * 2, y: 0, width: TILE_SIZE * 0.8, height: TILE_SIZE, dx: 0, dy: 0, onGround: false, acceleration: 0.25, 
            maxSpeed: 3.5, friction: 0.85, groundFriction: 0.6, initialJumpVelocity: -8.5, boostedJumpVelocity: -12.0,
            gravity: 0.28, jumpCutGravity: 0.5, coyoteTime: 4, coyoteTimeCounter: 0, hasJumpBoost: false, canBreakBricks: false,
            safetyBounces: 0, lastSafeX: 0, lastSafeY: 0, coinMagnetTimer: 0, scoreMultiplier: 1, scoreMultiplierTimer: 0,
        };

        // --- Game State ---
        const keys = { left: false, right: false, up: false };
        let cameraX = 0;
        let selectedTileType = 1; 
        let isEditMode = false;
        let score = 0;
        
        // --- Multi-Level State ---
        let gameProject = {};
        let currentLevelIndex = 0;
        let scoreAtLevelStart = 0;
        let levelData = []; 
        let initialLevelData = []; 
        
        let tileAnimations = [];
        let staticClouds = [];
        let onScreenMessage = { text: '', alpha: 0, timer: 0 };
        let isTransitioning = false;
        let isTouchDevice = false;
        let isTouchMovingPlayer = false; // New flag to track if touch is for player movement

        // --- Editor State ---
        let isPainting = false;
        let isMinimapDragging = false;
        let lastMouseX = 0; // Added for editor column positioning

        // --- Tile Definitions ---
        const TILE_EMPTY = 0, TILE_GROUND = 1, TILE_BRICK = 2, TILE_QUESTION = 3, TILE_BUMPER = 4, TILE_COIN = 5, TILE_GOAL = 6, TILE_USED_BLOCK = 7;
        const tileColors = { 
            [TILE_GROUND]: '#8B4513', [TILE_BRICK]: '#B22222', [TILE_QUESTION]: '#FFB300', [TILE_BUMPER]: '#808080', 
            [TILE_COIN]: '#FFD700', [TILE_GOAL]: '#4A148C', [TILE_USED_BLOCK]: '#795548'
        };
        const TILE_SPRITE_MAP = {
            [TILE_GROUND]: 'ground', [TILE_BRICK]: 'brick', [TILE_BUMPER]: 'bumper', [TILE_COIN]: 'coin', [TILE_USED_BLOCK]: 'used_block',
            [TILE_QUESTION]: 'question', 
            [TILE_GOAL]: 'goal', 
            'player': 'player', 'sky': 'sky', 'cloud': 'cloud'
        };

        // --- Custom Modals ---
        const confirmModal = document.getElementById('confirmModal');
        const confirmMessage = document.getElementById('confirmMessage');
        const confirmOk = document.getElementById('confirmOk');
        const confirmCancel = document.getElementById('confirmCancel');
        
        const promptModal = document.getElementById('promptModal');
        const promptMessage = document.getElementById('promptMessage');
        const promptInput = document.getElementById('promptInput');
        const promptOk = document.getElementById('promptOk');
        const promptCancel = document.getElementById('promptCancel');

        /**
         * Displays a confirmation dialog to the user.
         * @param {string} message - The message to display in the confirmation dialog.
         * @returns {Promise<boolean>} A promise that resolves to true if confirmed, false otherwise.
         */
        function showConfirm(message) {
            return new Promise((resolve) => {
                confirmMessage.textContent = message;
                confirmModal.style.display = 'flex';
                
                confirmOk.onclick = () => {
                    confirmModal.style.display = 'none';
                    resolve(true);
                };
                confirmCancel.onclick = () => {
                    confirmModal.style.display = 'none';
                    resolve(false);
                };
            });
        }

        /**
         * Displays a prompt dialog to the user to get text input.
         * @param {string} message - The message to display in the prompt dialog.
         * @param {string} [initialValue=''] - The initial value for the input field.
         * @returns {Promise<string|null>} A promise that resolves to the input value if confirmed, null otherwise.
         */
        function showPrompt(message, initialValue = '') {
            return new Promise((resolve) => {
                promptMessage.textContent = message;
                promptInput.value = initialValue;
                promptModal.style.display = 'flex';
                promptInput.focus();

                promptOk.onclick = () => {
                    promptModal.style.display = 'none';
                    resolve(promptInput.value);
                };
                promptCancel.onclick = () => {
                    promptModal.style.display = 'none';
                    resolve(null);
                };
            });
        }


        // --- Level Management ---
        /**
         * Creates a new game project with a default first level.
         */
        function createNewProject() {
            gameProject = {
                name: "My Awesome Project",
                sprites: getDefaultSprites(),
                levels: []
            };
            const firstLevelData = generateLevelData();
            gameProject.levels.push({ name: "Level 1", levelData: firstLevelData });
            currentLevelIndex = 0;
            loadLevel(0);
        }
        
        /**
         * Loads a specified level from the game project.
         * @param {number} levelIndex - The index of the level to load.
         * @param {boolean} [isNewGame=true] - True if starting a new game (resets score), false otherwise.
         */
        function loadLevel(levelIndex, isNewGame = true) {
            if (!gameProject.levels || levelIndex < 0 || levelIndex >= gameProject.levels.length) {
                console.error("Project or level not found, resetting.");
                createNewProject();
                return;
            }
            currentLevelIndex = levelIndex;
            levelData = JSON.parse(JSON.stringify(gameProject.levels[currentLevelIndex].levelData));
            initialLevelData = JSON.parse(JSON.stringify(gameProject.levels[currentLevelIndex].levelData));
            
            if(isNewGame) {
                score = 0;
                resetBonuses(); // Only reset bonuses if it's a new game (e.g., starting from Level 1)
            }
            scoreAtLevelStart = score;

            resetPlayerPosition();
            resizeAndDrawMinimap();
            updateAllPalettes(); // Ensure palettes are updated when a new level is loaded
        }

        /**
         * Generates new procedural level data.
         * This function creates a side-scrolling level with ground, gaps, floating platforms, coins, and question blocks.
         * @returns {Array<Array<number>>} The generated level data.
         */
        function generateLevelData() {
            const newGeneratedLevel = Array(LEVEL_HEIGHT_TILES).fill(0).map(() => Array(LEVEL_WIDTH_TILES).fill(TILE_EMPTY));
            let h = LEVEL_HEIGHT_TILES - 4; // Starting ground height
            
            // Calculate max jump height and distance in tiles for level generation
            let tempDy = player.initialJumpVelocity;
            let jumpHeight = 0;
            while(tempDy < 0) {
                jumpHeight -= tempDy;
                tempDy += player.gravity;
            }
            const maxJumpHeightInTiles = Math.floor(jumpHeight / TILE_SIZE);
            
            const timeInAir = (2 * -player.initialJumpVelocity) / player.gravity;
            const maxJumpDistancePixels = player.maxSpeed * timeInAir;
            const maxJumpDistanceInTiles = Math.floor(maxJumpDistancePixels / TILE_SIZE);
            const maxGapWidth = maxJumpDistanceInTiles - 2; // Max gap player can clear
            const minGapWidth = 2; // Minimum gap width

            let groundSegmentLength = 0;
            let gapLength = 0;

            for (let c = 0; c < LEVEL_WIDTH_TILES; c++) {
                // If currently in a gap, skip columns until gap ends
                if (gapLength > 0) { gapLength--; continue; }

                // If current ground segment is finished, decide what to generate next
                if (groundSegmentLength <= 0) {
                    // Introduce a gap or change ground height
                    if (c > 10 && c < LEVEL_WIDTH_TILES - 20 && Math.random() < 0.18) { // Chance to create a gap
                        gapLength = minGapWidth + Math.floor(Math.random() * (maxGapWidth - minGapWidth + 1));
                        groundSegmentLength = 8 + Math.floor(Math.random() * 10); // Length of ground after gap
                        
                        // Adjust height for next segment, ensuring it's jumpable
                        h += (Math.random() * 2 - 1);
                        if (h < LEVEL_HEIGHT_TILES - (maxJumpHeightInTiles + 3)) h = LEVEL_HEIGHT_TILES - (maxJumpHeightInTiles + 3);
                        if (h > LEVEL_HEIGHT_TILES - 3) h = LEVEL_HEIGHT_TILES - 3;
                        continue; 
                    } else { // Continue ground, possibly with height change
                        let prevH = h;
                        h += (Math.random() * 2 - 1) * 0.8; // Small height variation
                        // Clamp height within reasonable jumping bounds
                        if (h < LEVEL_HEIGHT_TILES - (maxJumpHeightInTiles + 2)) h = LEVEL_HEIGHT_TILES - (maxJumpHeightInTiles + 2);
                        if (h > LEVEL_HEIGHT_TILES - 3) h = LEVEL_HEIGHT_TILES - 3;
                        // Ensure height changes are not too steep to be unjumpable
                        if (Math.abs(h - prevH) > maxJumpHeightInTiles - 1) {
                            h = prevH + (maxJumpHeightInTiles - 1) * Math.sign(h-prevH);
                        }
                        groundSegmentLength = 6 + Math.floor(Math.random() * 12); // New ground segment length
                    }
                }
                groundSegmentLength--;

                // Place ground tiles
                for (let r = Math.floor(h); r < LEVEL_HEIGHT_TILES; r++) {
                    if(r >= 0 && r < LEVEL_HEIGHT_TILES) newGeneratedLevel[r][c] = TILE_GROUND;
                }

                // Add level elements (platforms, coins, question blocks, bumpers)
                if (c > 5 && c < LEVEL_WIDTH_TILES - 15 && groundSegmentLength > 2) {
                    const event = Math.random();
                    if (event < 0.1) { // Floating Platforms
                        const platformY = Math.floor(h - (Math.random() * (maxJumpHeightInTiles - 3) + 2)); 
                        const platformLength = 3 + Math.floor(Math.random() * 4);
                        for (let i = 0; i < platformLength; i++) {
                            if (c + i < LEVEL_WIDTH_TILES && platformY > 0) {
                                newGeneratedLevel[platformY][c + i] = TILE_BRICK;
                                if (Math.random() < 0.3) newGeneratedLevel[platformY - 1][c + i] = TILE_COIN;
                            }
                        }
                        c += platformLength; // Advance column to avoid overlapping features
                        groundSegmentLength = 0; // Reset ground segment to potentially start new one
                    } else if (event < 0.25) { // Coins
                        const patternType = Math.random();
                        const coinY = Math.floor(h - 3 - Math.random() * (maxJumpHeightInTiles - 4));
                        let patternLength = 0;
                        if (patternType < 0.4) { // Arc
                            patternLength = 4;
                            if (c + patternLength < LEVEL_WIDTH_TILES && coinY - 1 > 0) {
                                newGeneratedLevel[coinY][c] = TILE_COIN; newGeneratedLevel[coinY - 1][c + 1] = TILE_COIN;
                                newGeneratedLevel[coinY - 1][c + 2] = TILE_COIN; newGeneratedLevel[coinY][c + 3] = TILE_COIN;
                            }
                        } else if (patternType < 0.8) { // Line
                            patternLength = 3 + Math.floor(Math.random() * 3);
                            for(let i = 0; i < patternLength; i++) if (c + i < LEVEL_WIDTH_TILES && coinY > 0) newGeneratedLevel[coinY][c + i] = TILE_COIN;
                        } else { // Cluster
                            patternLength = 2;
                             if (c + 1 < LEVEL_WIDTH_TILES && coinY - 1 > 0) {
                                newGeneratedLevel[coinY][c] = TILE_COIN; newGeneratedLevel[coinY][c+1] = TILE_COIN;
                                newGeneratedLevel[coinY-1][c] = TILE_COIN; newGeneratedLevel[coinY-1][c+1] = TILE_COIN;
                            }
                        }
                        c += patternLength;
                    } else if (event < 0.38) { // Question Block
                        const blockY = Math.floor(h - (3 + Math.random() * (maxJumpHeightInTiles - 4)));
                        if (blockY > 0 && newGeneratedLevel[blockY + 1][c] === TILE_EMPTY && newGeneratedLevel[blockY][c] === TILE_EMPTY) {
                           newGeneratedLevel[blockY][c] = TILE_QUESTION;
                        }
                    } else if (event < 0.41) { // Bumper
                        const groundY = Math.floor(h);
                        if(groundY > 0 && newGeneratedLevel[groundY-1][c] === TILE_EMPTY) {
                            newGeneratedLevel[groundY - 1][c] = TILE_BUMPER;
                            c++;
                        }
                    }
                }
            }
            
            // Place the goal at the end of the level
            const finalH = Math.floor(h);
            const goalX = LEVEL_WIDTH_TILES - 5;
            const goalY = finalH - 3; 

            if (goalY > 0) {
                newGeneratedLevel[goalY][goalX] = TILE_GOAL;
                // Clear any ground below the goal to make it float
                for (let r = goalY + 1; r < LEVEL_HEIGHT_TILES; r++) {
                    if (r >= 0 && r < LEVEL_HEIGHT_TILES) newGeneratedLevel[r][goalX] = TILE_EMPTY;
                }
            } else {
                // Fallback if goalY is too high
                if (finalH - 2 > 0) newGeneratedLevel[finalH - 2][goalX] = TILE_GOAL;
            }
            return newGeneratedLevel;
        }

        /**
         * Resets the player's position to the start of the level.
         */
        function resetPlayerPosition() {
            player.x = TILE_SIZE * 2;
            player.y = TILE_SIZE * (LEVEL_HEIGHT_TILES - 10);
            player.dx = 0; player.dy = 0; cameraX = 0;
            // No call to resetBonuses() here, as they should persist
        }
        
        /**
         * Resets all player bonuses (jump boost, brick break, safety bounces, etc.).
         * This function is now only called when starting a *new game* (e.g., from Level 1).
         */
        function resetBonuses() {
            player.hasJumpBoost = false; player.canBreakBricks = false; player.safetyBounces = 0;
            player.coinMagnetTimer = 0; player.scoreMultiplier = 1; player.scoreMultiplierTimer = 0;
        }

        /**
         * Handles player death, either by using a safety bounce or resetting the level.
         */
        function handlePlayerDeath() {
            if (player.safetyBounces > 0) {
                player.safetyBounces--;
                player.x = player.lastSafeX;
                player.y = player.lastSafeY;
                player.dy = -1; // Give a small upward bounce
            } else {
                score = scoreAtLevelStart; // Reset score to what it was at the start of the level
                // Do NOT reset bonuses here, as they should persist even after death within a level
                levelData = JSON.parse(JSON.stringify(initialLevelData)); // Reset level to initial state
                resetPlayerPosition();
            }
        }
        
        /**
         * Transitions to the next level or generates a new one if all existing levels are completed.
         */
        function goToNextLevel() {
            if (isTransitioning) return; // Prevent multiple transitions
            isTransitioning = true;
            const nextLevelIndex = currentLevelIndex + 1;

            if (nextLevelIndex < gameProject.levels.length) {
                // Load existing next level
                onScreenMessage = { text: `Level ${nextLevelIndex + 1}`, alpha: 1, timer: 120 };
                setTimeout(() => {
                    loadLevel(nextLevelIndex, false); // Pass false to indicate not a new game, so bonuses persist
                    isTransitioning = false;
                }, 1000);
            } else {
                // Generate a new level if no more pre-defined levels exist
                const newLevelData = generateLevelData();
                const newLevelName = `Generated Level ${gameProject.levels.length + 1}`;
                gameProject.levels.push({ name: newLevelName, levelData: newLevelData });
                onScreenMessage = { text: `New Level Generated!`, alpha: 1, timer: 180 }; // Longer message for new level
                setTimeout(() => {
                    loadLevel(gameProject.levels.length - 1, false); // Pass false to indicate not a new game
                    isTransitioning = false;
                }, 2000); // Longer delay for new level generation message
            }
        }

        /**
         * Initializes static background elements like clouds.
         */
        function initializeBackground() {
            staticClouds = [];
            for (let i = 0; i < 40; i++) {
                staticClouds.push({
                    x: Math.random() * LEVEL_WIDTH_TILES * TILE_SIZE,
                    y: Math.random() * (canvas.height - 150),
                    size: 0.5 + Math.random() * 1.5
                });
            }
        }

        // --- Drawing Functions ---
        /**
         * Draws all game elements on the canvas.
         */
        function drawAll() {
            if (!gameProject.sprites) return;
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas
            drawBackground(); // Draw background (sky and clouds)
            drawLevel(); // Draw all tiles
            if(isEditMode) drawGrid(); // Draw grid if in edit mode
            drawPlayer(); 
            drawUI();
        }

        /**
         * Draws the background, including sky color and clouds.
         */
        function drawBackground() {
            ctx.fillStyle = gameProject.sprites.sky[0][0];
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            staticClouds.forEach(cloud => {
                const screenX = cloud.x - cameraX * 0.5; // Parallax effect
                renderSprite(ctx, 'cloud', screenX, cloud.y, TILE_SIZE * 2 * cloud.size);
            });
        }
        
        /**
         * Draws all tiles in the current level.
         */
        function drawLevel() {
            // Determine visible columns based on camera position
            const startCol = Math.floor(cameraX / TILE_SIZE);
            const endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 1;
            for (let r=0; r<LEVEL_HEIGHT_TILES; r++) {
                for (let c=startCol; c<endCol && c < LEVEL_WIDTH_TILES; c++) {
                    const tile = levelData[r] ? levelData[r][c] : TILE_EMPTY;
                    
                    // Only draw non-empty tiles. The background is already drawn by drawBackground().
                    if (tile === TILE_EMPTY) {
                        // In edit mode, we still need to ensure the sky is drawn in empty tile spots,
                        // and then the grid will be drawn on top by drawGrid().
                        // No explicit clearRect/fillRect here, as drawAll() already clears the whole canvas
                        // and drawBackground() fills it.
                        continue; // Skip drawing for empty tiles, background already covers it.
                    }
                    
                    const x = Math.floor(c * TILE_SIZE - cameraX);
                    // Apply animation offset for question/brick blocks
                    const anim = tileAnimations.find(a => a.r === r && a.c === c);
                    const y = Math.floor(r * TILE_SIZE) + (anim ? anim.yOffset : 0);
                    
                    const spriteName = TILE_SPRITE_MAP[tile];
                    if (spriteName && gameProject.sprites[spriteName]) {
                        // Render sprite if available
                        renderSprite(ctx, spriteName, x, y, TILE_SIZE);
                    } else { 
                        // Fallback to solid color if no sprite defined
                        ctx.fillStyle = tileColors[tile];
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        /**
         * Draws a single tile at the specified grid coordinates.
         * This function is no longer used for main canvas painting in edit mode to avoid flickering.
         * The `drawAll()` function is now called every frame in edit mode.
         * @param {number} r - Row index.
         * @param {number} c - Column index.
         */
        function drawSingleTile(r, c) {
            // This function is kept for reference but its direct use for canvas updates in edit mode is removed.
            // The full drawAll() handles updates now.
        }


        /**
         * Draws the game UI, including score, level, and active power-ups.
         */
        function drawUI() { 
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 4; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;

            ctx.font = "16px 'Press Start 2P'"; ctx.fillStyle = "white"; ctx.textAlign = "left"; 
            ctx.fillText("SCORE:" + score, 10, 25); 
            ctx.fillText("LEVEL:" + (currentLevelIndex + 1), 10, 50);

            let powerupY = 75;
            ctx.font = "12px 'Press Start 2P'";
            if (player.hasJumpBoost) { ctx.fillText("JUMP BOOST", 10, powerupY); powerupY += 20; }
            if (player.canBreakBricks) { ctx.fillText("BRICK BREAK", 10, powerupY); powerupY += 20; }
            if (player.safetyBounces > 0) { ctx.fillText(`REBOUNDS: ${player.safetyBounces}`, 10, powerupY); powerupY += 20; }
            if (player.coinMagnetTimer > 0) { ctx.fillText("COIN MAGNET", 10, powerupY); powerupY += 20; }
            if (player.scoreMultiplierTimer > 0) { ctx.fillText(`${player.scoreMultiplier}x SCORE`, 10, powerupY); powerupY += 20; }
            ctx.restore();

            // Draw on-screen messages (e.g., "Level 2", "Game Over")
            if (onScreenMessage.alpha > 0) {
                ctx.save();
                ctx.globalAlpha = onScreenMessage.alpha;
                ctx.font = "24px 'Press Start 2P'"; ctx.textAlign = 'center'; ctx.fillStyle = 'white';
                ctx.shadowColor = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 4; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                ctx.fillText(onScreenMessage.text, canvas.width / 2, canvas.height / 2);
                ctx.restore();
            }
        }
        
        /**
         * Draws the grid lines in edit mode.
         */
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            for (let x = - (cameraX % TILE_SIZE); x < canvas.width; x += TILE_SIZE) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += TILE_SIZE) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }
        
        /**
         * Draws the player character.
         */
        function drawPlayer() {
            if(!isEditMode) renderSprite(ctx, 'player', Math.floor(player.x - cameraX), Math.floor(player.y), player.height);
        }

        /**
         * Resizes and redraws the minimap based on the container width.
         */
        function resizeAndDrawMinimap() {
            const mapPaletteContainer = document.getElementById('mapPaletteContainer');
            // Ensure container is visible and has a width before resizing
            if (!mapPaletteContainer || !mapPaletteContainer.offsetParent || mapPaletteContainer.clientWidth === 0) return;
            const newWidth = mapPaletteContainer.clientWidth - 30; // Account for padding
            if (newWidth > 0) {
                minimapCanvas.width = newWidth;
                minimapCanvas.height = (minimapCanvas.width / LEVEL_WIDTH_TILES) * LEVEL_HEIGHT_TILES;
            }
            drawMinimap();
        }

        /**
         * Draws the minimap, showing the entire level and the current camera view.
         */
        function drawMinimap() {
            if (!minimapCanvas.width) return;
            const TILE_W = minimapCanvas.width / LEVEL_WIDTH_TILES;
            const TILE_H = minimapCanvas.height / LEVEL_HEIGHT_TILES;
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            for(let r=0; r<LEVEL_HEIGHT_TILES; r++) {
                for(let c=0; c<LEVEL_WIDTH_TILES; c++) {
                    const tile = levelData[r][c];
                    if(tile !== TILE_EMPTY) {
                        minimapCtx.fillStyle = tileColors[tile];
                        minimapCtx.fillRect(c * TILE_W, r * TILE_H, TILE_W, TILE_H);
                    }
                }
            }
            // Draw camera view rectangle on minimap
            minimapCtx.save();
            minimapCtx.strokeStyle = 'yellow'; minimapCtx.lineWidth = 2;
            const rectX = (cameraX / TILE_SIZE) * TILE_W;
            const rectW = (canvas.width / TILE_SIZE) * TILE_W;
            minimapCtx.strokeRect(rectX, 0, rectW, minimapCanvas.height);
            minimapCtx.restore();
        }

        // --- Game Logic & Physics ---
        /**
         * The main game loop, updating game state and drawing.
         */
        function gameLoop() {
            updateOnScreenMessage();
            if (!isEditMode) {
                updatePlayer();
                updateCamera();
                updateBonuses();
                drawAll(); // Full redraw in play mode
            } else {
                updateEditorState(); // Call updateEditorState in edit mode
                // In edit mode, we always do a full redraw for visibility
                drawAll(); 
            }
            updateTileAnimations();
            handleCollisions(); 
            if (isEditMode) {
                drawMinimap(); // Redraw minimap in edit mode as camera might move
            }
            requestAnimationFrame(gameLoop);
        }

        /**
         * Updates the on-screen message's alpha and timer.
         */
        function updateOnScreenMessage() {
            if (onScreenMessage.timer > 0) {
                onScreenMessage.timer--;
                if (onScreenMessage.timer < 60) {
                    onScreenMessage.alpha = onScreenMessage.timer / 60; // Fade out effect
                }
            }
        }

        /**
         * Updates the position of the editor column based on cameraX.
         * This function helps shift the editor column from right to left as the camera moves.
         */
        function updateEditorState() {
            const isOverlayLayout = window.innerWidth >= 768; // Apply only on tablet/desktop
            if (!isOverlayLayout) return; // Only apply this logic for larger screens

            const maxCameraX = (LEVEL_WIDTH_TILES * TILE_SIZE) - canvas.width;
            const minCameraX = 0;

            // If camera is near the end of the level, move editor to left
            if (cameraX >= maxCameraX - (canvas.width / 4)) { // Adjust threshold as needed
                editorColumn.classList.add('editor-column--left');
            }
            // If camera is near the start of the level, move editor to right
            else if (cameraX <= minCameraX + (canvas.width / 4)) { // Adjust threshold as needed
                editorColumn.classList.remove('editor-column--left');
            }
        }
        
        /**
         * Updates player position, velocity, and ground status based on input and physics.
         */
        function updatePlayer() {
            if (onScreenMessage.timer > 0) return; // Player cannot move during screen messages
            if (player.onGround) {
                player.coyoteTimeCounter = player.coyoteTime; // Reset coyote time on ground
                player.lastSafeX = player.x; // Update last safe position
                player.lastSafeY = player.y;
            } else {
                player.coyoteTimeCounter--; // Decrement coyote time when in air
            }
            // Horizontal movement
            if (keys.left) player.dx -= player.acceleration;
            else if (keys.right) player.dx += player.acceleration;
            else {
                if (player.onGround) player.dx *= player.groundFriction; // Apply ground friction
                else player.dx *= player.friction; // Apply air friction
            }
            // Clamp horizontal speed
            if (player.dx > player.maxSpeed) player.dx = player.maxSpeed;
            if (player.dx < -player.maxSpeed) player.dx = -player.maxSpeed;
            if (Math.abs(player.dx) < 0.1) player.dx = 0; // Stop if speed is very low

            // Vertical movement (gravity and jump cut)
            player.dy += (player.dy < 0 && !keys.up) ? player.jumpCutGravity : player.gravity;
            player.onGround = false; // Assume not on ground until collision detection proves otherwise
        }

        /**
         * Updates the state of player bonuses (coin magnet, score multiplier).
         */
        function updateBonuses() {
            // Coin Magnet
            if (player.coinMagnetTimer > 0) {
                player.coinMagnetTimer--;
                const magnetRadius = TILE_SIZE * 4; // Radius for coin attraction
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                // Check for coins in visible area (optimization)
                const startCol = Math.floor(cameraX / TILE_SIZE);
                const endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 1;
                for (let r = 0; r < LEVEL_HEIGHT_TILES; r++) {
                    for (let c = startCol; c < endCol && c < LEVEL_WIDTH_TIles; c++) {
                        if (levelData[r] && levelData[r][c] === TILE_COIN) {
                            const coinX = c * TILE_SIZE + TILE_SIZE / 2;
                            const coinY = r * TILE_SIZE + TILE_SIZE / 2;
                            const distance = Math.sqrt(Math.pow(playerCenterX - coinX, 2) + Math.pow(playerCenterY - coinY, 2));
                            if (distance < magnetRadius) {
                                levelData[r][c] = TILE_EMPTY; // Remove coin
                                score += 5 * player.scoreMultiplier; // Add score
                                drawMinimap(); // Update minimap
                            }
                        }
                    }
                }
            }
            // Score Multiplier
            if (player.scoreMultiplierTimer > 0) {
                player.scoreMultiplierTimer--;
                if (player.scoreMultiplierTimer === 0) {
                    player.scoreMultiplier = 1; // Reset multiplier when timer runs out
                }
            }
        }
        
        /**
         * Updates the position of animated tiles (e.g., question block bounce).
         */
        function updateTileAnimations() {
            for (let i = tileAnimations.length - 1; i >= 0; i--) {
                const anim = tileAnimations[i];
                anim.dy += 0.4; // Apply gravity to animation
                anim.yOffset += anim.dy;
                if (anim.yOffset >= 0) { // Animation finished when it returns to original position
                    anim.yOffset = 0;
                    tileAnimations.splice(i, 1); // Remove animation
                }
            }
        }

        /**
         * Handles player collisions with tiles and updates player state accordingly.
         */
        function handleCollisions() {
            if(isEditMode || onScreenMessage.timer > 0) return; // No collisions in edit mode or during messages

            let shouldGoToNextLevel = false;

            // Horizontal collision detection
            player.x += player.dx;
            let hResolved = false;
            let left = Math.floor(player.x / TILE_SIZE);
            let right = Math.floor((player.x + player.width - 1) / TILE_SIZE);
            let top = Math.floor(player.y / TILE_SIZE);
            let bottom = Math.floor((player.y + player.height - 1) / TILE_SIZE);

            for (let r = top; r <= bottom; r++) {
                for (let c = left; c <= right; c++) {
                    const tile = levelData[r] ? levelData[r][c] : TILE_EMPTY;
                    if (tile > TILE_EMPTY && tile !== TILE_COIN) { // Collide with solid tiles, but not coins
                         if (tile === TILE_BUMPER) {
                            // Bumpers reverse player direction
                            if (player.dx > 0) player.dx = -10;
                            else if (player.dx < 0) player.dx = 10;
                         } else {
                            // Standard solid block collision
                            if (player.dx > 0) player.x = c * TILE_SIZE - player.width;
                            else if (player.dx < 0) player.x = (c + 1) * TILE_SIZE;
                            player.dx = 0;
                         }
                        hResolved = true;
                        break;
                    }
                }
                if (hResolved) break;
            }

            // Vertical collision detection
            player.y += player.dy;
            let vResolved = false;
            left = Math.floor(player.x / TILE_SIZE);
            right = Math.floor((player.x + player.width - 1) / TILE_SIZE);
            top = Math.floor(player.y / TILE_SIZE);
            bottom = Math.floor((player.y + player.height - 1) / TILE_SIZE);

            for (let r = top; r <= bottom; r++) {
                for (let c = left; c <= right; c++) {
                    const tile = levelData[r] ? levelData[r][c] : TILE_EMPTY;
                    if (tile > TILE_EMPTY && tile !== TILE_COIN) {
                        if (player.dy > 0) { // Falling and hit something below
                            if (tile === TILE_BUMPER) {
                                player.dy = player.boostedJumpVelocity * 1.2; // Bounce off bumper
                            } else {
                                player.y = r * TILE_SIZE - player.height; // Snap to top of tile
                                player.dy = 0;
                                player.onGround = true; // Player is on ground
                                if (tile === TILE_GOAL) shouldGoToNextLevel = true; // Reached goal
                            }
                            vResolved = true;
                            break;
                        } else if (player.dy < 0) { // Jumping and hit something above
                             if (tile === TILE_BUMPER) {
                                player.dy = 10; // Bounce off bumper
                             } else {
                                player.y = (r + 1) * TILE_SIZE; // Snap to bottom of tile
                                player.dy = 0.1; // Small downward push to re-enable gravity
                                if (tile === TILE_QUESTION) {
                                    levelData[r][c] = TILE_USED_BLOCK; // Change question block to used block
                                    score += 50 * player.scoreMultiplier;
                                    // Grant random power-up
                                    const rand = Math.random();
                                    if (rand < 0.2) player.hasJumpBoost = true;
                                    else if (rand < 0.4) player.canBreakBricks = true;
                                    else if (rand < 0.6) player.safetyBounces += 5;
                                    else if (rand < 0.8) player.coinMagnetTimer = 600;
                                    else { player.scoreMultiplier = 2; player.scoreMultiplierTimer = 600; }
                                    tileAnimations.push({ r, c, yOffset: 0, dy: -3 }); // Animate block
                                    resizeAndDrawMinimap();
                                 } else if (tile === TILE_BRICK) {
                                    if (player.canBreakBricks) {
                                        levelData[r][c] = TILE_EMPTY; // Break brick
                                        score += 10 * player.scoreMultiplier;
                                    } else {
                                        tileAnimations.push({ r, c, yOffset: 0, dy: -2 }); // Animate brick (no break)
                                    }
                                }
                             }
                            vResolved = true;
                            break;
                        }
                    }
                }
                if (vResolved) break;
            }
            
            // Coin collection after movement
            left = Math.floor(player.x / TILE_SIZE);
            right = Math.floor((player.x + player.width - 1) / TILE_SIZE);
            top = Math.floor(player.y / TILE_SIZE);
            bottom = Math.floor((player.y + player.height - 1) / TILE_SIZE);
            for (let r = top; r <= bottom; r++) {
                for (let c = left; c <= right; c++) {
                    if (levelData[r] && levelData[r][c] === TILE_COIN) {
                        levelData[r][c] = TILE_EMPTY; // Collect coin
                        score += 5 * player.scoreMultiplier;
                        resizeAndDrawMinimap();
                    }
                }
            }

            // Boundary checks for player
            if (player.x < 0) player.x = 0;
            if (player.y > canvas.height) handlePlayerDeath(); // Player fell off screen
            if (shouldGoToNextLevel) goToNextLevel(); // Transition if goal reached
        }
        
        /**
         * Updates the camera position to follow the player.
         */
        function updateCamera() {
            if (onScreenMessage.timer > 0) return; // Camera frozen during messages
            const deadzone = canvas.width/3; // Area where player can move without camera moving
            const pCamX = player.x - cameraX; // Player's X relative to camera
            if (pCamX > canvas.width - deadzone) cameraX = player.x - (canvas.width - deadzone);
            else if (pCamX < deadzone) cameraX = player.x - deadzone;
            // Clamp camera to level boundaries
            cameraX = Math.max(0, Math.min(cameraX, LEVEL_WIDTH_TILES * TILE_SIZE - canvas.width));
        }

        // --- Event Listeners ---
        /**
         * Sets up all event listeners for user input and UI interactions.
         */
        function setupEventListeners() {
            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice) {
                document.body.classList.add('is-touch');
                
                // Touch controls for player movement
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scrolling and pinch-to-zoom immediately

                    if (isEditMode) {
                        isPainting = true; 
                        handleCanvasInteraction(e, true);
                        return;
                    }

                    const rect = canvas.getBoundingClientRect();
                    const touchX = e.touches[0].clientX - rect.left;

                    const halfWidth = rect.width / 2; // Use display width for accurate touch zones

                    // Reset keys for a fresh touch input
                    keys.left = false;
                    keys.right = false;
                    keys.up = false; // Ensure jump is not active on touchstart for movement

                    isTouchMovingPlayer = true; // This touch is for player movement

                    if (touchX < halfWidth) {
                        keys.left = true;
                    } else { // touchX >= halfWidth
                        keys.right = true;
                    }
                }, { passive: false });

                // No touchmove listener for gameplay needed for "hold to move, release to jump"
                // The touchstart sets the direction, and it remains active until touchend.

                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault(); // Prevent default touch end behavior immediately

                    if (isEditMode) {
                        isPainting = false;
                        return;
                    }
                    
                    // Only trigger jump if all fingers are up (no more touches)
                    if (e.touches.length === 0 && isTouchMovingPlayer && (player.onGround || player.coyoteTimeCounter > 0)) {
                        player.dy = player.hasJumpBoost ? player.boostedJumpVelocity : player.initialJumpVelocity;
                        player.onGround = false;
                        player.coyoteTimeCounter = 0;
                    }

                    // Reset all keys and touch movement flag on touch end
                    keys.left = false;
                    keys.right = false;
                    keys.up = false;
                    isTouchMovingPlayer = false;
                }, { passive: false });

            }

            // Keyboard controls for player movement and modal closing
            window.addEventListener('keydown', e => { 
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal-overlay').forEach(m => m.style.display = 'none');
                }
                if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
                if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
                if ((e.key === 'ArrowUp' || e.code === 'Space')) { 
                    if (!keys.up && (player.onGround || player.coyoteTimeCounter > 0)) {
                        player.dy = player.hasJumpBoost ? player.boostedJumpVelocity : player.initialJumpVelocity;
                        player.onGround = false;
                        player.coyoteTimeCounter = 0;
                    }
                    keys.up = true;
                    e.preventDefault(); 
                }
            });
            window.addEventListener('keyup', e => { 
                if (e.key === 'ArrowLeft') keys.left = false; 
                if (e.key === 'ArrowRight') keys.right = false; 
                if (e.key === 'ArrowUp' || e.code === 'Space') keys.up = false; 
            });
            
            /**
             * Handles placing or removing a tile on the game canvas in edit mode.
             * @param {MouseEvent|TouchEvent} e - The event object.
             * @param {boolean} isInitialClick - True if this is the initial mousedown/touchstart, false for mousemove/touchmove.
             */
            function handleCanvasInteraction(e, isInitialClick) {
                const rect = canvas.getBoundingClientRect(); 
                const touch = e.touches ? e.touches[0] : e;
                const mouseX = touch.clientX-rect.left; const mouseY = touch.clientY-rect.top;
                const worldX = mouseX+cameraX; const worldY = mouseY;
                const tileX=Math.floor(worldX/TILE_SIZE); const tileY=Math.floor(worldY/TILE_SIZE);
                
                if (tileX>=0 && tileX<LEVEL_WIDTH_TILES && tileY>=0 && tileY<LEVEL_HEIGHT_TILES) { 
                    const currentTile = levelData[tileY][tileX];
                    let tileChanged = false;

                    if (isInitialClick) {
                        // Toggle logic for initial click
                        if (selectedTileType === TILE_GOAL) { // Special handling for Goal tile
                            for (let r = 0; r < LEVEL_HEIGHT_TILES; r++) {
                                for (let c = 0; c < LEVEL_WIDTH_TILES; c++) {
                                    if (levelData[r][c] === TILE_GOAL) {
                                        levelData[r][c] = TILE_EMPTY;
                                        // drawSingleTile(r, c); // No longer needed with full redraw
                                    }
                                }
                            }
                        }
                        levelData[tileY][tileX] = currentTile === selectedTileType ? TILE_EMPTY : selectedTileType;
                        tileChanged = true;
                    } else { // Dragging (mousemove/touchmove)
                        // Only place tiles, do not remove when dragging
                        if (currentTile !== selectedTileType) {
                            levelData[tileY][tileX] = selectedTileType;
                            tileChanged = true;
                        }
                    }

                    if (tileChanged) {
                        // Update current level data and initial level data for reset purposes
                        gameProject.levels[currentLevelIndex].levelData = JSON.parse(JSON.stringify(levelData));
                        initialLevelData = JSON.parse(JSON.stringify(levelData));
                        // drawSingleTile(tileY, tileX); // Removed for full redraw in edit mode
                        drawMinimap(); // Update minimap to reflect changes
                    }
                }
            }
            
            // Event listeners for placing tiles in edit mode (mouse)
            canvas.addEventListener('mousedown', e => { if (!isEditMode) return; isPainting = true; handleCanvasInteraction(e, true); });
            canvas.addEventListener('mousemove', e => { if (!isEditMode || !isPainting) return; handleCanvasInteraction(e, false); });
            // Touch events for edit mode are now handled within the main touchstart/touchmove/touchend listeners
            
            // Toggle between play and edit modes
            modeToggleButton.addEventListener('click', () => { 
                isEditMode=!isEditMode; 
                modeToggleButton.textContent = isEditMode ? 'Play' : 'Edit';
                editorColumn.classList.toggle('is-editing', isEditMode);
                document.body.classList.toggle('play-mode', !isEditMode);
                if (!isEditMode) {
                    // When switching to play mode, save current level state as initial
                    initialLevelData = JSON.parse(JSON.stringify(levelData));
                    gameProject.levels[currentLevelIndex].levelData = JSON.parse(JSON.stringify(levelData));
                    scoreAtLevelStart = score;
                    resetPlayerPosition();
                    drawAll(); // Full redraw when switching to play mode
                } else {
                    // When switching to edit mode, ensure full redraw and minimap is drawn
                    drawAll(); 
                    setTimeout(resizeAndDrawMinimap, 0);
                }
            });

            /**
             * Sets the camera position based on a click/touch on the minimap.
             * @param {MouseEvent|TouchEvent} e - The event object.
             */
            function setCameraFromMinimap(e) {
                const rect = minimapCanvas.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                const clickX = touch.clientX - rect.left;
                const percentX = clickX / rect.width;
                cameraX = (LEVEL_WIDTH_TILES * TILE_SIZE * percentX) - (canvas.width / 2);
                // Clamp camera position
                cameraX = Math.max(0, Math.min(cameraX, LEVEL_WIDTH_TILES * TILE_SIZE - canvas.width));
            }
            // Event listeners for minimap dragging
            minimapCanvas.addEventListener('mousedown', e => { isMinimapDragging = true; setCameraFromMinimap(e); });
            minimapCanvas.addEventListener('mousemove', e => { if(isMinimapDragging) setCameraFromMinimap(e); });
            minimapCanvas.addEventListener('touchstart', e => { e.preventDefault(); isMinimapDragging = true; setCameraFromMinimap(e); }, { passive: false });
            minimapCanvas.addEventListener('touchmove', e => { e.preventDefault(); if(isMinimapDragging) setCameraFromMinimap(e); }, { passive: false });

            // --- Data Persistence ---
            document.getElementById('saveJson').addEventListener('click', () => {
                const data = JSON.stringify(gameProject);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([data], {type: 'application/json'}));
                a.download = 'game-project.json';
                a.click();
            });

            document.getElementById('loadJson').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file'; input.accept = '.json,application/json';
                input.onchange = e => { 
                    const file = e.target.files[0]; 
                    const reader = new FileReader();
                    reader.onload = readerEvent => {
                        try {
                            const data = JSON.parse(readerEvent.target.result);
                            if (data.levels && data.sprites) { // Basic validation
                                gameProject = data;
                                loadLevel(0, true);
                            } else {
                                console.error("Invalid project file format.");
                                showConfirm("Invalid project file format. Please select a valid game project JSON.");
                            }
                        } catch (error) {
                            console.error("Error parsing JSON file:", error);
                            showConfirm("Error loading project. Please ensure it's a valid JSON file.");
                        }
                    };
                    reader.readAsText(file);
                }
                input.click();
            });
            
            const loadSessionModal = document.getElementById('loadSessionModal');
            const saveSessionModal = document.getElementById('saveSessionModal');
            const sessionList = document.getElementById('sessionList');
            const sessionNameInput = document.getElementById('sessionNameInput');

            document.getElementById('saveLocal').addEventListener('click', () => {
                sessionNameInput.value = gameProject.name || 'My Awesome Project';
                saveSessionModal.style.display = 'flex';
                sessionNameInput.focus();
            });

            document.getElementById('confirmSaveButton').addEventListener('click', () => {
                const projectName = sessionNameInput.value.trim();
                if (!projectName) { 
                    showConfirm("Project name cannot be empty.");
                    return; 
                }
                
                gameProject.name = projectName;
                const savedProjects = JSON.parse(localStorage.getItem('8bit-projects') || '{}');
                savedProjects[projectName] = { ...gameProject, date: new Date().toLocaleString() };
                localStorage.setItem('8bit-projects', JSON.stringify(savedProjects));
                saveSessionModal.style.display = 'none';
            });

            document.getElementById('loadLocal').addEventListener('click', () => {
                const savedProjects = JSON.parse(localStorage.getItem('8bit-projects') || '{}');
                sessionList.innerHTML = '';
                
                if (Object.keys(savedProjects).length === 0) {
                    sessionList.innerHTML = '<li>No saved projects found.</li>';
                } else {
                    for (const key in savedProjects) {
                        const project = savedProjects[key];
                        const li = document.createElement('li');
                        li.className = 'session-item';
                        li.innerHTML = `<div class="session-name">${project.name}</div><div class="session-date">Last saved: ${project.date}</div>`;
                        li.onclick = () => {
                            gameProject = project;
                            loadLevel(0, true);
                            loadSessionModal.style.display = 'none';
                        };
                        sessionList.appendChild(li);
                    }
                }
                loadSessionModal.style.display = 'flex';
            });
            
            document.getElementById('closeLoadModal').addEventListener('click', () => loadSessionModal.style.display = 'none');
            document.getElementById('closeSaveModal').addEventListener('click', () => { saveSessionModal.style.display = 'none'; });

            document.getElementById('generateLevel').addEventListener('click', () => {
                const newLevelData = generateLevelData();
                const newLevelName = `Level ${gameProject.levels.length + 1}`;
                gameProject.levels.push({ name: newLevelName, levelData: newLevelData });
                loadLevel(gameProject.levels.length - 1, false); // Load the newly added level
                onScreenMessage = { text: `Created ${newLevelName}`, alpha: 1, timer: 120 };
            });

            // --- Level Manager ---
            const levelManagerModal = document.getElementById('levelManagerModal');
            const levelManagerList = document.getElementById('levelManagerList');

            /**
             * Opens the level manager modal and populates the list of levels.
             */
            function openLevelManager() {
                levelManagerList.innerHTML = '';
                gameProject.levels.forEach((level, index) => {
                    const item = document.createElement('li');
                    item.className = 'level-manager-item';
                    item.innerHTML = `
                        <span class="level-name">${index + 1}: ${level.name}</span>
                        <div class="level-controls">
                            <button class="button" data-action="play" data-index="${index}">Play</button>
                            <button class="button" data-action="edit" data-index="${index}">Edit</button>
                            <button class="button" data-action="rename" data-index="${index}">Rename</button>
                            <button class="button" data-action="up" data-index="${index}" ${index === 0 ? 'disabled' : ''}>&#9650;</button>
                            <button class="button" data-action="down" data-index="${index}" ${index === gameProject.levels.length - 1 ? 'disabled' : ''}>&#9660;</button>
                            <button class="button button--secondary" data-action="delete" data-index="${index}">Del</button>
                        </div>
                    `;
                    levelManagerList.appendChild(item);
                });
                levelManagerModal.style.display = 'flex';
            }

            // Event listener for actions within the level manager (play, edit, rename, delete, reorder)
            levelManagerList.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const action = target.dataset.action;
                const index = parseInt(target.dataset.index);

                switch (action) {
                    case 'play':
                        loadLevel(index, true); // Load and start new game with selected level
                        isEditMode = false;
                        modeToggleButton.textContent = 'Edit';
                        editorColumn.classList.remove('is-editing');
                        document.body.classList.add('play-mode');
                        levelManagerModal.style.display = 'none';
                        break;
                    case 'edit':
                        loadLevel(index, false); // Load selected level for editing (keep score)
                        isEditMode = true;
                        modeToggleButton.textContent = 'Play';
                        editorColumn.classList.add('is-editing');
                        document.body.classList.remove('play-mode');
                        levelManagerModal.style.display = 'none';
                        break;
                    case 'rename': {
                        const newName = await showPrompt('Enter new level name:', gameProject.levels[index].name);
                        if (newName) {
                            gameProject.levels[index].name = newName;
                            openLevelManager(); // Re-render list to show new name
                        }
                        break;
                    }
                    case 'delete': {
                        const confirmed = await showConfirm(`Are you sure you want to delete "${gameProject.levels[index].name}"?`);
                        if (confirmed) {
                            gameProject.levels.splice(index, 1); // Remove level
                            if (currentLevelIndex >= index) currentLevelIndex = Math.max(0, currentLevelIndex - 1); // Adjust current level index
                            if (gameProject.levels.length === 0) gameProject.levels.push({ name: "Level 1", levelData: generateLevelData() }); // Ensure at least one level exists
                            loadLevel(currentLevelIndex, false); // Load adjusted current level
                            openLevelManager(); // Re-render list
                        }
                        break;
                    }
                    case 'up':
                        if (index > 0) {
                            // Swap levels in array
                            [gameProject.levels[index], gameProject.levels[index - 1]] = [gameProject.levels[index - 1], gameProject.levels[index]];
                            openLevelManager(); // Re-render list
                        }
                        break;
                    case 'down':
                        if (index < gameProject.levels.length - 1) {
                            // Swap levels in array
                            [gameProject.levels[index], gameProject.levels[index + 1]] = [gameProject.levels[index + 1], gameProject.levels[index]];
                            openLevelManager(); // Re-render list
                        }
                        break;
                }
            });

            document.getElementById('manageLevels').addEventListener('click', openLevelManager);
            document.getElementById('closeLevelManagerModal').addEventListener('click', () => { levelManagerModal.style.display = 'none'; });
        }

        // --- Sprite Editor ---
        // Default color palette for the sprite editor
        const PALETTE = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#8B4513', '#B22222', '#228B22', '#795548', '#D32F2F', '#E53935', '#A12020', '#3B82F6', null];
        let activeEditorSprite = 'player'; // Currently selected sprite for editing
        let activeColor = PALETTE[0]; // Currently selected color for painting pixels
        let isPixelPainting = false; // Flag for ongoing pixel painting
        let colorToEdit = { swatch: null, index: -1, oldColor: null }; // State for custom color picker

        /**
         * Simple pseudo-random number generator for consistent sprite generation.
         * @param {number} seed - The seed for the random number.
         * @returns {number} A pseudo-random number between 0 and 1.
         */
        function pseudoRandom(seed) { let x = Math.sin(seed) * 10000; return x - Math.floor(x); }

        /**
         * Returns a set of default pixel art sprites for the game.
         * @returns {object} An object containing sprite data for player, ground, brick, etc.
         */
        function getDefaultSprites() {
            const defaults = {};
            // Player sprite (16x16)
            defaults.player = Array(16).fill(0).map(() => Array(16).fill(null));
            for(let r=0; r<16; r++) for(let c=2; c<14; c++) defaults.player[r][c] = '#D32F2F'; // Body
            for(let r=2; r<6; r++) for(let c=4; c<7; c++) defaults.player[r][c] = '#FFFFFF'; // Eyes
            for(let r=2; r<6; r++) for(let c=9; c<12; c++) defaults.player[r][c] = '#FFFFFF'; // Eyes
            for(let r=14; r<16; r++) for(let c=0; c<6; c++) defaults.player[r][c] = '#A12020'; // Left leg
            for(let r=14; r<16; r++) for(let c=10; c<16; c++) defaults.player[r][c] = '#A12020'; // Right leg

            // Ground sprite (16x16)
            defaults.ground = Array(16).fill(0).map(() => Array(16).fill('#8B4513'));
            const dirtColors = ['#6B4226', '#7B4E2E', '#8B5A36'];
            for (let r = 0; r < 16; r++) for (let c = 0; c < 16; c++) if (pseudoRandom(r * 100 + c) < 0.2) defaults.ground[r][c] = dirtColors[Math.floor(pseudoRandom(c * 100 + r) * dirtColors.length)];

            // Brick sprite (16x16)
            defaults.brick = Array(16).fill(0).map(() => Array(16).fill('#B22222'));
            const mortar = '#000000';
            for(let c=0; c<16; c++) { defaults.brick[8][c] = mortar; defaults.brick[7][c] = mortar; }
            for(let r=0; r<8; r++) { defaults.brick[r][8] = mortar; defaults.brick[r][7] = mortar; }
            for(let r=9; r<16; r++) { defaults.brick[r][4] = mortar; defaults.brick[r][3] = mortar; defaults.brick[r][12] = mortar; defaults.brick[r][11] = mortar; }

            // Question Block sprite (16x16) - yellow block with black core
            defaults.question = Array(16).fill(0).map(() => Array(16).fill('#FFB300')); // Yellow base
            for(let r=4; r<12; r++) {
                for(let c=4; c<12; c++) {
                    defaults.question[r][c] = '#000000'; // Black core
                }
            }

            // Used Block sprite (16x16)
            defaults.used_block = Array(16).fill(0).map(() => Array(16).fill('#795548'));
            for(let i=0; i<16; i++) { defaults.used_block[0][i] = '#5D4037'; defaults.used_block[15][i] = '#5D4037'; defaults.used_block[i][0] = '#5D4037'; defaults.used_block[i][15] = '#5D4037';}

            // Bumper sprite (16x16)
            defaults.bumper = Array(16).fill(0).map(() => Array(16).fill(null));
            const bumperColor = '#C0C0C0'; const bumperShadow = '#808080';
            for(let r=0; r<16; r++) for(let c=2; c<14; c++) defaults.bumper[r][c] = bumperColor;
            for(let r=2; r<14; r++) for(let c=0; c<16; c++) defaults.bumper[r][c] = bumperColor;
            for(let i=0; i<16; i++) { defaults.bumper[i][0] = bumperShadow; defaults.bumper[i][15] = bumperShadow; }
            for(let i=4; i<12; i+=2) for(let c=2; c<14; c++) defaults.bumper[i][c] = bumperShadow;

            // Coin sprite (16x16)
            defaults.coin = Array(16).fill(0).map(() => Array(16).fill(null));
            for(let r=4; r<12; r++) for(let c=4; c<12; c++) defaults.coin[r][c] = '#FFD700';

            // Goal sprite (16x16) - purple block with magenta core
            defaults.goal = Array(16).fill(0).map(() => Array(16).fill('#4A148C')); // Purple base
            for(let r=4; r<12; r++) {
                for(let c=4; c<12; c++) {
                    defaults.goal[r][c] = '#FF00FF'; // Magenta core
                }
            }

            // Sky color (1x1, represents a single color)
            defaults.sky = [['#3B82F6']];

            // Cloud sprite (16x32, wider than tall)
            defaults.cloud = Array(16).fill(0).map(() => Array(32).fill(null));
            for(let r=4; r<12; r++) for(let c=2; c<30; c++) defaults.cloud[r][c] = '#FFFFFF';
            for(let r=0; r<8; r++) for(let c=8; c<24; c++) defaults.cloud[r][c] = '#FFFFFF';
            return defaults;
        }

        /**
         * Renders a pixel art sprite onto a given canvas context.
         * @param {CanvasRenderingContext2D} ctx - The 2D rendering context.
         * @param {string} spriteName - The name of the sprite to render.
         * @param {number} x - The X coordinate to draw the sprite.
         * @param {number} y - The Y coordinate to draw the sprite.
         * @param {number} size - The desired height of the sprite in pixels.
         */
        function renderSprite(ctx, spriteName, x, y, size) {
            const spriteData = gameProject.sprites[spriteName];
            if (!spriteData) return;
            const rows = spriteData.length; 
            const cols = spriteData[0].length;
            // Calculate pixel dimensions based on desired size and sprite aspect ratio
            const pixelH = size / rows; 
            const pixelW = (size / rows) * (cols / rows); // Maintain aspect ratio
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const color = spriteData[r][c];
                    if (color) {
                        ctx.fillStyle = color;
                        // Use Math.floor and Math.ceil for pixel-perfect rendering
                        ctx.fillRect(Math.floor(x + c * pixelW), Math.floor(y + r * pixelH), Math.ceil(pixelW), Math.ceil(pixelH));
                    }
                }
            }
        }
        
        /**
         * Updates the background images of tile palette icons with their corresponding sprite data.
         */
        function updateAllPalettes() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 32; tempCanvas.height = 32;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;
            
            // Update tile palette icons
            Object.entries(TILE_SPRITE_MAP).forEach(([key, spriteName]) => { 
                if (!gameProject.sprites[spriteName]) return;
                tempCtx.clearRect(0,0,32,32);

                // Draw a checkerboard background for transparency for specific sprites
                if (spriteName === 'player' || spriteName === 'cloud' || spriteName === 'coin' || spriteName === 'bumper' || spriteName === 'goal' || spriteName === 'question') {
                    const checkerSize = 4;
                    for (let y = 0; y < tempCanvas.height; y += checkerSize) {
                        for (let x = 0; x < tempCanvas.width; x += checkerSize) {
                            tempCtx.fillStyle = (x / checkerSize + y / checkerSize) % 2 === 0 ? '#cccccc' : '#999999';
                            tempCtx.fillRect(x, y, checkerSize, checkerSize);
                        }
                    }
                }

                renderSprite(tempCtx, spriteName, 0, 0, 32);
                const dataUrl = tempCanvas.toDataURL();
                
                let elementId;
                // Map TILE_ constants to their corresponding HTML element IDs
                if (parseInt(key) === TILE_GROUND) elementId = 'key-ground';
                else if (parseInt(key) === TILE_BRICK) elementId = 'key-brick';
                else if (parseInt(key) === TILE_BUMPER) elementId = 'key-bumper';
                else if (parseInt(key) === TILE_COIN) elementId = 'key-coin';
                else if (parseInt(key) === TILE_USED_BLOCK) elementId = 'key-used-block'; 
                else if (parseInt(key) === TILE_QUESTION) elementId = 'key-question'; 
                else if (parseInt(key) === TILE_GOAL) elementId = 'key-goal'; 
                
                if (elementId) {
                    const element = document.getElementById(elementId);
                    if (element) element.style.backgroundImage = `url(${dataUrl})`;
                }
            });

            // Update sprite editor buttons with their respective sprite images
            Object.keys(gameProject.sprites).forEach(spriteName => {
                const tempCanvasForSprite = document.createElement('canvas'); // Use a new temp canvas for each sprite
                tempCanvasForSprite.width = 32;
                tempCanvasForSprite.height = 32;
                const tempCtxForSprite = tempCanvasForSprite.getContext('2d');
                tempCtxForSprite.imageSmoothingEnabled = false;

                // Draw a checkerboard background for transparency
                const checkerSize = 4;
                for (let y = 0; y < tempCanvasForSprite.height; y += checkerSize) {
                    for (let x = 0; x < tempCanvasForSprite.width; x += checkerSize) {
                        tempCtxForSprite.fillStyle = (x / checkerSize + y / checkerSize) % 2 === 0 ? '#cccccc' : '#999999';
                        tempCtxForSprite.fillRect(x, y, checkerSize, checkerSize);
                    }
                }

                // Render small version of sprite onto temporary canvas with background
                renderSprite(tempCtxForSprite, spriteName, 0, 0, 32); 
                const dataUrl = tempCanvasForSprite.toDataURL();
                
                const spriteEditorButtonIcon = document.querySelector(`.sprite-edit-button[data-sprite-name='${spriteName}'] .sprite-icon-preview`);
                if (spriteEditorButtonIcon) {
                    spriteEditorButtonIcon.style.backgroundImage = `url(${dataUrl})`;
                }
            });
        }
        
        const spriteEditorModal = document.getElementById('spriteEditorModal');
        const spriteListDiv = document.getElementById('sprite-editor-list');
        const pixelGrid = document.getElementById('pixel-grid');
        const colorPaletteDiv = document.getElementById('color-palette');
        
        /**
         * Sets up the sprite editor UI, including the list of sprites and the color palette.
         */
        function setupSpriteEditor() {
            spriteListDiv.innerHTML = '';
            // Create buttons for each sprite to select for editing
            // Ensure all sprites from gameProject.sprites are included, not just TILE_SPRITE_MAP
            Object.keys(gameProject.sprites).forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'sprite-edit-button';
                btn.dataset.spriteName = name;
                // Add a div inside the button to hold the sprite icon
                const iconPreview = document.createElement('div');
                iconPreview.className = 'sprite-icon-preview';
                btn.appendChild(iconPreview);
                // Set accessible name for screen readers
                btn.setAttribute('aria-label', `Edit ${name} sprite`);

                btn.onclick = () => openEditorForSprite(name);
                spriteListDiv.appendChild(btn);
            });
            colorPaletteDiv.innerHTML = '';
            // Create color swatches for the palette
            PALETTE.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color === null ? '#555' : color; // Placeholder for null (transparent)
                if (color === null) swatch.style.backgroundImage = 'linear-gradient(45deg, #808080 25%, transparent 25%), linear-gradient(-45deg, #808080 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #808080 75%), linear-gradient(-45deg, transparent 75%, #808080 75%)';
                swatch.dataset.color = color; swatch.dataset.index = index;
                swatch.onclick = () => selectColorForPainting(swatch);
                swatch.ondblclick = () => openColorEditor(swatch); // Double click to edit color
                colorPaletteDiv.appendChild(swatch);
            });
            // Initial update of sprite editor button icons
            updateAllPalettes();
        }
        
        /**
         * Opens the pixel editor for a specific sprite.
         * @param {string} spriteName - The name of the sprite to edit.
         */
        function openEditorForSprite(spriteName) {
            activeEditorSprite = spriteName;
            // Highlight the active sprite button
            document.querySelectorAll('.sprite-edit-button').forEach(b => b.classList.toggle('active', b.dataset.spriteName === spriteName));
            const spriteData = gameProject.sprites[spriteName];
            // Handle cases where spriteData might be null or empty (e.g., for 'sky' which is 1x1)
            const rows = spriteData ? spriteData.length : 1; 
            const cols = spriteData && spriteData[0] ? spriteData[0].length : 1;

            pixelGrid.innerHTML = '';
            pixelGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`; // Set grid columns dynamically
            // Adjust pixel grid size based on sprite dimensions
            const pixelSize = Math.min(320 / cols, 320 / rows); // Max 320px width/height for grid
            pixelGrid.style.width = `${pixelSize * cols}px`;
            pixelGrid.style.height = `${pixelSize * rows}px`;
            pixelGrid.style.gridAutoRows = `${pixelSize}px`; // Ensure rows are also sized correctly

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel'; pixel.dataset.index = r * cols + c;
                    const color = spriteData && spriteData[r] ? spriteData[r][c] : null; // Handle potential undefined
                    pixel.style.backgroundColor = color || 'transparent'; // Display pixel color
                    pixel.onmousedown = (e) => { isPixelPainting = true; paintPixel(e.target); };
                    pixel.onmouseover = (e) => { if (isPixelPainting) paintPixel(e.target); };
                    pixelGrid.appendChild(pixel);
                }
            }
        }

        /**
         * Selects a color from the palette for painting.
         * @param {HTMLElement} swatchEl - The color swatch element that was clicked.
         */
        function selectColorForPainting(swatchEl) {
            activeColor = swatchEl.dataset.color === 'null' ? null : swatchEl.dataset.color;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            swatchEl.classList.add('selected');
        }

        /**
         * Opens the custom color picker to edit a palette color.
         * @param {HTMLElement} swatchEl - The color swatch element to edit.
         */
        function openColorEditor(swatchEl) {
            const color = swatchEl.dataset.color === 'null' ? null : swatchEl.dataset.color;
            if (color === null) return; // Cannot edit transparent color
            const index = parseInt(swatchEl.dataset.index);
            colorToEdit = { swatch: swatchEl, index: index, oldColor: null }; // oldColor should be the actual color, not null
            if (PALETTE[index] !== null) { // Ensure oldColor is set only if it's not the transparent swatch
                colorToEdit.oldColor = PALETTE[index];
            }
            const rect = swatchEl.getBoundingClientRect();
            customColorPicker.style.display = 'block';
            // Position the color picker above the swatch
            customColorPicker.style.top = `${rect.top - customColorPicker.offsetHeight - 5}px`;
            customColorPicker.style.left = `${rect.left + rect.width / 2 - customColorPicker.offsetWidth / 2}px`;
            drawColorPicker(color); // Initialize picker with current color
        }
        
        /**
         * Paints a single pixel on the sprite grid with the active color.
         * @param {HTMLElement} pixelEl - The pixel element to paint.
         */
        function paintPixel(pixelEl) {
            const spriteData = gameProject.sprites[activeEditorSprite];
            const cols = spriteData[0].length;
            const index = parseInt(pixelEl.dataset.index);
            const r = Math.floor(index / cols); const c = index % cols;
            spriteData[r][c] = activeColor; // Update sprite data
            pixelEl.style.backgroundColor = activeColor || 'transparent'; // Update pixel visual
        }
        
        /**
         * Saves the currently active sprite by updating all palettes.
         */
        function saveActiveSprite() { updateAllPalettes(); }
        
        document.getElementById('openSpriteEditor').addEventListener('click', () => {
             spriteEditorModal.style.display = 'flex';
             openEditorForSprite(activeEditorSprite);
             selectColorForPainting(colorPaletteDiv.children[0]); // Select first color by default
        });
        document.getElementById('closeSpriteEditorModal').addEventListener('click', () => {
             spriteEditorModal.style.display = 'none';
             customColorPicker.style.display = 'none'; // Close color picker if open
        });

        // --- Custom Color Picker Logic ---
        const customColorPicker = document.getElementById('custom-color-picker');
        let pickerHue = 0, pickerSaturation = 1, pickerLightness = 0.5, isPickingColor = false;

        /**
         * Initializes the custom color picker with a given color.
         * @param {string} initialColor - The hex color string to initialize the picker with.
         */
        function drawColorPicker(initialColor) {
            const [h, s, l] = hexToHsl(initialColor);
            pickerHue = h; pickerSaturation = s; pickerLightness = l;
            drawColorBox(); 
            drawSlider();
        }

        /**
         * Draws the main color selection box (saturation and lightness).
         */
        function drawColorBox() {
            const colorBox = document.getElementById('color-box');
            const colorBoxCtx = colorBox.getContext('2d');
            colorBox.width = 200; colorBox.height = 150;
            // Fill with current hue
            colorBoxCtx.fillStyle = `hsl(${pickerHue}, 100%, 50%)`;
            colorBoxCtx.fillRect(0, 0, colorBox.width, colorBox.height);
            // Add white gradient for saturation
            const whiteGradient = colorBoxCtx.createLinearGradient(0, 0, colorBox.width, 0);
            whiteGradient.addColorStop(0, 'rgba(255,255,255,1)'); whiteGradient.addColorStop(1, 'rgba(255,255,255,0)');
            colorBoxCtx.fillStyle = whiteGradient; colorBoxCtx.fillRect(0, 0, colorBox.width, colorBox.height);
            // Add black gradient for lightness
            const blackGradient = colorBoxCtx.createLinearGradient(0, 0, 0, colorBox.height);
            blackGradient.addColorStop(0, 'rgba(0,0,0,0)'); blackGradient.addColorStop(1, 'rgba(0,0,0,1)');
            colorBoxCtx.fillStyle = blackGradient; colorBoxCtx.fillRect(0, 0, colorBox.width, colorBox.height);
            // Position indicator
            document.getElementById('color-box-indicator').style.left = `${pickerSaturation * colorBox.width}px`;
            document.getElementById('color-box-indicator').style.top = `${(1 - pickerLightness) * colorBox.height}px`;
        }

        /**
         * Draws the hue slider.
         */
        function drawSlider() {
            const colorSlider = document.getElementById('color-slider');
            const colorSliderCtx = colorSlider.getContext('2d');
            colorSlider.width = 200; colorSlider.height = 20;
            const sliderGradient = colorSliderCtx.createLinearGradient(0, 0, colorSlider.width, 0);
            // Create a gradient across all hues
            for (let i = 0; i <= 360; i += 30) sliderGradient.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
            colorSliderCtx.fillStyle = sliderGradient; colorSliderCtx.fillRect(0, 0, colorSlider.width, colorSlider.height);
        }

        /**
         * Updates the selected color based on mouse/touch position in the color box.
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function updateColorFromPicker(e) {
            const rect = document.getElementById('color-box').getBoundingClientRect();
            pickerSaturation = (e.clientX - rect.left) / rect.width;
            pickerLightness = 1 - ((e.clientY - rect.top) / rect.height);
            pickerSaturation = Math.max(0, Math.min(1, pickerSaturation)); // Clamp values
            pickerLightness = Math.max(0, Math.min(1, pickerLightness));
            drawColorBox();
        }

        // Event listeners for color picker interaction
        document.getElementById('color-box').addEventListener('mousedown', e => { isPickingColor = true; updateColorFromPicker(e); });
        document.getElementById('color-slider').addEventListener('mousedown', e => {
            isPickingColor = true;
            const rect = document.getElementById('color-slider').getBoundingClientRect();
            pickerHue = ((e.clientX - rect.left) / rect.width) * 360; // Update hue
            drawColorBox(); // Redraw color box with new hue
        });
        window.addEventListener('mousemove', e => {
            if (isPickingColor) {
                if (e.target.id === 'color-box') updateColorFromPicker(e);
                if (e.target.id === 'color-slider') {
                    const rect = document.getElementById('color-slider').getBoundingClientRect();
                    pickerHue = ((e.clientX - rect.left) / rect.width) * 360;
                    drawColorBox();
                }
            }
        });

        // Confirm button for color picker
        document.getElementById('picker-ok').addEventListener('click', () => {
            const newColor = hslToHex(pickerHue, pickerSaturation, pickerLightness);
            const { index, oldColor } = colorToEdit;
            PALETTE[index] = newColor; // Update color in global palette
            // Update all sprites that used the old color to the new color
            for (const spriteName in gameProject.sprites) {
                const spriteData = gameProject.sprites[spriteName];
                for (let r = 0; r < spriteData.length; r++) for (let c = 0; c < spriteData[r].length; c++) if (spriteData[r][c] === oldColor) spriteData[r][c] = newColor;
            }
            activeColor = newColor; // Set new color as active
            setupSpriteEditor(); // Re-setup editor to reflect changes
            openEditorForSprite(activeEditorSprite);
            document.querySelector(`.color-swatch[data-index='${index}']`).classList.add('selected'); // Re-select swatch
            document.getElementById('custom-color-picker').style.display = 'none'; // Close picker
        });
        // Cancel button for color picker
        document.getElementById('picker-cancel').addEventListener('click', () => { document.getElementById('custom-color-picker').style.display = 'none'; });

        /**
         * Converts a hex color string to HSL values.
         * @param {string} hex - The hex color string (e.g., "#RRGGBB").
         * @returns {Array<number>} An array [h, s, l] where h is 0-360, s and l are 0-1.
         */
        function hexToHsl(hex) {
            if (!hex) return [0, 0, 0];
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result) return [0, 0, 0]; // Handle invalid hex
            let r = parseInt(result[1], 16) / 255, g = parseInt(result[2], 16) / 255, b = parseInt(result[3], 16) / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max == min) { h = s = 0; } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s, l];
        }

        /**
         * Converts HSL values to a hex color string.
         * @param {number} h - Hue (0-360).
         * @param {number} s - Saturation (0-1).
         * @param {number} l - Lightness (0-1).
         * @returns {string} The hex color string (e.g., "#RRGGBB").
         */
        function hslToHex(h, s, l) {
            let r, g, b;
            if (s == 0) { r = g = b = l; } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1; if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                }
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h / 360 + 1/3); g = hue2rgb(p, q, h / 360); b = hue2rgb(p, q, h / 360 - 1/3);
            }
            const toHex = x => { const hex = Math.round(x * 255).toString(16); return hex.length === 1 ? '0' + hex : hex; };
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // --- Initialisation ---
        /**
         * Initializes the game when the window loads.
         */
        function init() {
            createNewProject(); // Start a new project with a default level
            initializeBackground(); // Set up static background elements
            setupSpriteEditor(); // Initialize sprite editing tools
            setupEventListeners(); // Set up all user input listeners
            
            // Set initial mode to play mode
            document.body.classList.add('play-mode');
            editorColumn.classList.remove('is-editing');
            modeToggleButton.textContent = 'Edit';

            // Adjust player jump velocity for touch devices
            if (isTouchDevice) {
                player.initialJumpVelocity = -10.0; // Stronger initial jump
                player.boostedJumpVelocity = -14.0; // Stronger boosted jump
            }

            // Global mouse/touch up listeners to stop painting/dragging
            window.addEventListener('mouseup', () => {
                isPainting = false; 
                isMinimapDragging = false; 
                if (isPixelPainting) { isPixelPainting = false; saveActiveSprite(); }
                isPickingColor = false;
            });
            // window.addEventListener('touchend', () => { /* This is now handled by canvas.addEventListener('touchend') */ });
            // The global touchend listener is removed as it was interfering with the canvas-specific one.
            // The canvas-specific touchend now handles all necessary resets.
            
            gameLoop(); // Start the main game loop
        }

        window.onload = init; // Call init when the window has fully loaded
    </script>
</body>
</html>
